package jsonschema

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"reflect"
	"strings"
	"unicode"

	"github.com/caddyserver/caddy/v2"
	caddycmd "github.com/caddyserver/caddy/v2/cmd"
)

func init() {
	caddycmd.RegisterCommand(caddycmd.Command{
		Name:  "json-schema",
		Func:  cmdSchema,
		Usage: "[--output <file>]",
		Short: "Generate JSON schema for caddy json api",
		Long: `
JSON schema generator for caddy JSON configuration. More at https://json-schema.org

If --output is set, the schema is generated to the specified file. By default it is
generate to caddy_json_schema.json in the current directory.
`,
		Flags: func() *flag.FlagSet {
			fs := flag.NewFlagSet("json-schema", flag.ExitOnError)
			fs.String("output", "caddy_json_schema.json", "The file to write the generated schema")
			return fs
		}(),
	})
}

func cmdSchema(fs caddycmd.Flags) (int, error) {
	// if err := loadJSONDoc(); err != nil {
	// 	return 1, err
	// }

	if err := getAllModules(); err != nil {
		return 1, err
	}

	if err := generateSchema(); err != nil {
		return 1, err
	}

	return 0, nil
}

func getAllModules() error {
	for _, mod := range caddy.Modules() {
		split := strings.Split(mod, ".")

		parent := "" // top level modules
		name := split[len(split)-1]
		if len(split) >= 2 {
			// submodules
			parent = strings.Join(split[:len(split)-1], ".")
		}

		info, err := caddy.GetModule(mod)
		if err != nil {
			return err
		}

		if moduleMap[parent] == nil {
			moduleMap[parent] = Modules{}
		}

		newInfo := info.New()
		module := Module{
			Name: name,
			Type: newInfo,
			Field: Field{
				Name:   name,
				Module: mod,
			},
		}

		moduleMap[parent][name] = module
		flatModuleMap[mod] = module
	}

	// module docs
	{
		for namespace, list := range caddyDoc.Namespaces {
			for _, doc := range list {
				mod := namespace + "." + doc.Name
				if namespace == "" {
					mod = doc.Name
				}

				module := flatModuleMap[mod]
				module.Doc = doc.Structure
				flatModuleMap[mod] = module
			}
		}
	}

	{
		// populate global object
		definitions := map[string]*Schema{}
		// use separate loop to ensure module list has populated.
		for modName, module := range flatModuleMap {
			module.Field.populate(module.Type)
			definitions[modName] = module.Field.toSchema()
		}

		// full config
		configField := Field{}
		configField.populate(caddy.Config{})
		globalSchema = configField.toSchema()
		globalSchema.Definitions = definitions
		globalSchema.Description = configField.description("object")
		globalSchema.MarkdownDescription = globalSchema.Description

		// in case this schema is incomplete, support additional custom items.
		globalSchema.AdditionalItems = true
	}

	{
		// topLevel apps
		// globalSchema.AdditionalItems = true
		// apps := NewSchema()
		// apps.Description = caddyDoc.Structure.Doc
		// apps.MarkdownDescription = caddyDoc.Structure.Doc
		// for modName := range moduleMap[""] {
		// 	s := NewSchema()
		// 	s.setRef(modName)
		// 	apps.Properties[modName] = s
		// }
		// globalSchema.Properties["apps"] = apps
		// globalSchema.Required = []string{"apps"}
	}

	return nil
}

func generateSchema() error {
	f, err := os.OpenFile("schema.json", os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer f.Close()

	encoder := json.NewEncoder(f)
	encoder.SetIndent("", "  ")

	globalSchema.Title = "Caddy v2 autogenerated JSON schema"
	globalSchema.Type = "object"

	// var err error
	err = encoder.Encode(globalSchema)
	return err

}

// Field ...
type Field struct {
	// keep track of the current module
	Module string
	Doc    *DocStruct

	Name   string
	Fields []Field
	Type   string

	Array bool
	Map   bool

	// array/map type
	Nest *Field

	// Module loaders
	Loader     []string // list of modules
	LoaderKey  string   // inline_key
	LoaderType reflect.Type
}

func (f Field) description(fieldType string) string {
	doc := ""
	if f.Doc != nil {
		doc = f.Doc.Doc
	}

	typ := reflect.TypeOf(flatModuleMap[f.Module].Type)
	if typ != nil {
		if typ.Kind() == reflect.Ptr {
			typ = typ.Elem()
		}
		// only show link for public fields
		if typ.Name() != "" {
			c := rune(typ.Name()[0])
			if unicode.IsUpper(c) && unicode.IsLetter(c) {
				godoc := fmt.Sprintf("[godoc](https://pkg.go.dev/%s#%s)", typ.PkgPath(), typ.Name())
				if doc != "" {
					doc = godoc + "\n\n" + doc
				} else {
					doc = godoc
				}
			}
		}
	}

	info := fmt.Sprintf("%s: `%s`  \nModule: `%s`  \n", f.Name, fieldType, f.Module)
	if f.Module == "" {
		info = fmt.Sprintf("%s: `%s`  \n", f.Name, fieldType)
	}
	return info + doc
}

func (f Field) toSchema() *Schema {
	var s = NewSchema()
	s.setType(f.Type)

	if len(f.Loader) > 0 {
		sl := NewSchema()

		if f.LoaderKey != "" {
			// when loader key is set, we expect an array.
			// combine {if, then} to improve suggestions.
			names := []string{}
			for _, l := range f.Loader {
				sub := NewSchema()

				sif := NewSchema()
				{
					split := strings.Split(l, ".")
					name := split[len(split)-1]

					tmp := NewSchema()
					tmp.Const = name
					names = append(names, name)

					sif.Properties[f.LoaderKey] = tmp
					sub.If = sif
				}

				sthen := NewSchema()
				{
					sthen.setRef(l)
					sub.Then = sthen
				}

				sl.AllOf = append(sl.AllOf, sub)
			}

			// make loaderKey a required field
			inline := NewSchema()
			{
				tmp := NewSchema()
				tmp.setType("string")
				tmp.Enum = names
				desc := "`%s` key to identify specified module.  \n%s: `string`  \nModule: `%s`"
				tmp.Description = fmt.Sprintf(desc, f.Name, f.LoaderKey, f.Module)
				tmp.MarkdownDescription = tmp.Description

				inline.Properties[f.LoaderKey] = tmp
				sl.AllOf = append(sl.AllOf, inline)
			}

			sl.Required = []string{f.LoaderKey}
		} else {
			// when loader key is absent, we expect a map
			for _, l := range f.Loader {
				split := strings.Split(l, ".")
				name := split[len(split)-1]

				ref := NewSchema()
				ref.setRef(l)

				sl.Properties[name] = ref
			}
		}

		// hack to determine the module loader type
		var tField Field
		tField.populate(reflect.Zero(f.LoaderType).Interface())
		loaderSchema := tField.toSchema()
		// determine how nested the module loader is
		var chain []*Schema
		for cs := loaderSchema; cs.ArrayItems != nil || cs.AdditionalProperties != nil; {
			chain = append(chain, cs)
			if cs.ArrayItems != nil {
				cs = cs.ArrayItems
			} else if cs.AdditionalProperties != nil {
				cs = cs.AdditionalProperties
			}
		}

		switch len(chain) {
		case 1:
			// module
			s.setType("object")
			s = sl
		case 2:
			if f.LoaderKey == "" {
				// moduleMap
				s.setType("object")
				s = sl
			} else {
				// []module
				s.setType("array")
				s.ArrayItems = sl
			}
		case 3:
			// []moduleMap
			s.setType("array")
			s.ArrayItems = sl
		}
	}

	for _, field := range f.Fields {
		s.Properties[field.Name] = field.toSchema()
	}

	// get arrays and maps
	for cs, outer, nest := s, &f, f.Nest; nest != nil; outer, nest = nest, nest.Nest {
		props := map[string]*Schema{}
		for _, field := range nest.Fields {
			props[field.Name] = field.toSchema()
		}
		if outer.Array {
			cs.setType("array")
			cs.ArrayItems = NewSchema()
			cs.ArrayItems.setType(nest.Type)
			cs.ArrayItems.Properties = props

			// nest schema
			cs = cs.ArrayItems
		}

		if outer.Map {
			cs.setType("object")
			cs.AdditionalProperties = NewSchema()
			cs.AdditionalProperties.Properties = props

			// nest schema
			cs = cs.AdditionalProperties
		}
	}

	// now we're certain of the type
	s.Description = f.description(s.Type)
	s.MarkdownDescription = f.description(s.Type)
	return s
}

func (f *Field) populate(s interface{}) {
	v := reflect.ValueOf(s)

	elemVal := func() interface{} { return reflect.Zero(v.Type().Elem()).Interface() }

	switch v.Kind() {
	case reflect.Struct:
		f.populateStruct(v.Type())

	case reflect.Ptr:
		// discard the pointer, use the underlying type
		f.populate(elemVal())

	case reflect.Slice:
		f.Array = true
		f.Nest = &Field{
			Module: f.Module,
			Name:   f.Name + ".nest",
		}
		f.Nest.populate(elemVal())

	case reflect.Map:
		f.Map = true
		f.Nest = &Field{
			Module: f.Module,
			Name:   f.Name + ".nest",
		}
		f.Nest.populate(elemVal())

	default:
		f.populateStruct(v.Type())
	}

}

func (f *Field) populateStruct(t reflect.Type) {
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	if t.Kind() != reflect.Struct {
		f.Type = t.Kind().String()
		return
	}

	for _, ff := range allFields(t) {
		jsonTag, ok := ff.Tag.Lookup("json")
		if !ok || jsonTag == "-" {
			continue
		}

		field := Field{
			Module: f.Module,
			Name:   strings.TrimSuffix(jsonTag, ",omitempty"),
		}

		caddyTag, ok := ff.Tag.Lookup("caddy")
		if ok {
			split := strings.Fields(caddyTag)
			namespace := split[0] // 1 is inline_key
			namespace = strings.TrimPrefix(namespace, "namespace=")
			// use namespace as module
			field.Module = namespace
			field.LoaderType = ff.Type

			if len(split) > 1 {
				field.LoaderKey = strings.TrimPrefix(split[1], "inline_key=")
			}

			for key := range moduleMap[namespace] {
				modulePath := key
				if namespace != "" {
					modulePath = namespace + "." + key
				}
				field.Loader = append(field.Loader, modulePath)
			}
		} else {
			vf := reflect.Zero(ff.Type)
			field.populate(vf.Interface())
		}

		f.Fields = append(f.Fields, field)
	}

}

func allFields(t reflect.Type) []reflect.StructField {
	// dereference pointer
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	// reject non-structs
	if t.Kind() != reflect.Struct {
		return nil
	}

	var fields []reflect.StructField

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)

		if f.Anonymous {
			fields = append(fields, allFields(f.Type)...)
		} else {
			fields = append(fields, f)
		}

	}
	return fields
}
