package jsonschema

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"reflect"
	"strings"
	"unicode"

	"github.com/caddyserver/caddy/v2"
	caddycmd "github.com/caddyserver/caddy/v2/cmd"
)

func init() {
	// caddy.RegisterModule(Middleware{})
	// httpcaddyfile.RegisterHandlerDirective("visitors_ip", parseCaddyfile)
	caddycmd.RegisterCommand(caddycmd.Command{
		Name:  "json-schema",
		Func:  cmdSchema,
		Usage: "[--output <file>]",
		Short: "Generate JSON schema for caddy json api",
		Long: `
JSON schema generator for caddy JSON configuration. More at https://json-schema.org

If --output is set, the schema is generated to the specified file. By default it is
generate to caddy_json_schema.json in the current directory.
`,
		Flags: func() *flag.FlagSet {
			fs := flag.NewFlagSet("json-schema", flag.ExitOnError)
			fs.String("output", "caddy_json_schema.json", "The file to write the generated schema")
			return fs
		}(),
	})
}

func cmdSchema(fs caddycmd.Flags) (int, error) {
	if err := loadJSONDoc(); err != nil {
		return 1, err
	}

	if err := getAllModules(); err != nil {
		return 1, err
	}

	if err := generateSchema(); err != nil {
		return 1, err
	}

	return 0, nil
}

func getAllModules() error {
	for _, mod := range caddy.Modules() {
		split := strings.Split(mod, ".")

		parent := "" // top level modules
		name := split[len(split)-1]
		if len(split) >= 2 {
			// submodules
			parent = strings.Join(split[:len(split)-1], ".")
		}

		info, err := caddy.GetModule(mod)
		if err != nil {
			return err
		}

		if moduleMap[parent] == nil {
			moduleMap[parent] = Modules{}
		}

		newInfo := info.New()
		module := Module{
			Name: name,
			Type: newInfo,
			Field: Field{
				Name:   name,
				Module: mod,
			},
		}

		moduleMap[parent][name] = module
		flatModuleMap[mod] = module
	}

	// module docs
	{
		for namespace, list := range caddyDoc.Namespaces {
			for _, doc := range list {
				mod := namespace + "." + doc.Name
				if namespace == "" {
					mod = doc.Name
				}

				module := flatModuleMap[mod]
				module.Docs = doc.Docs
				flatModuleMap[mod] = module
			}
		}
	}

	{
		// use separate loop to ensure module list has populated.
		for modName, module := range flatModuleMap {
			module.Field.populate(module.Type)
			globalSchema.Definitions[modName] = module.Field.toSchema()
		}
	}

	{
		// topLevel apps
		globalSchema.AdditionalItems = true
		apps := NewSchema()
		for modName := range moduleMap[""] {
			s := NewSchema()
			s.setRef(modName)
			apps.Properties[modName] = s
		}
		globalSchema.Properties["apps"] = apps
		globalSchema.Required = []string{"apps"}
	}

	return nil
}

func generateSchema() error {
	f, err := os.OpenFile("schema.json", os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer f.Close()

	encoder := json.NewEncoder(f)
	encoder.SetIndent("", "  ")

	globalSchema.Title = "Caddy v2 autogenerated JSON schema"
	globalSchema.Type = "object"

	// var err error
	err = encoder.Encode(globalSchema)
	return err

}

// Field ...
type Field struct {
	// keep track of the current module
	Module string
	Docs   string

	Name   string
	Fields []Field
	Type   string

	Array bool
	Map   bool

	// array/map type
	Nest *Field

	// Module loaders
	Loader    []string
	LoaderKey string // inline_key
}

func (f Field) description(fieldType string) string {
	doc := f.Docs
	if f.Docs == "" {
		typ := reflect.TypeOf(flatModuleMap[f.Module].Type)
		if typ != nil {
			if typ.Kind() == reflect.Ptr {
				typ = typ.Elem()
			}
			// only show link for public fields
			if typ.Name() != "" {
				c := rune(typ.Name()[0])
				if unicode.IsUpper(c) && unicode.IsLetter(c) {
					doc = fmt.Sprintf("https://pkg.go.dev/%s#%s", typ.PkgPath(), typ.Name())
				}
			}
		}
	}
	info := fmt.Sprintf("%s\nModule: %s", fieldType, f.Module)
	return info + "\n" + doc
}

func (f Field) toSchema() *Schema {
	var s = NewSchema()
	s.setType(f.Type)

	if len(f.Loader) > 0 {
		s.setType("array")
		s.ArrayItems = NewSchema()

		if f.LoaderKey != "" {
			// handlers e.t.c.
			names := []string{}
			for _, l := range f.Loader {
				sub := NewSchema()

				sif := NewSchema()
				{
					split := strings.Split(l, ".")
					name := split[len(split)-1]

					tmp := NewSchema()
					tmp.Const = name
					names = append(names, name)

					sif.Properties[f.LoaderKey] = tmp
					sub.If = sif
				}

				sthen := NewSchema()
				{
					sthen.setRef(l)
					sub.Then = sthen
				}

				s.ArrayItems.AllOf = append(s.ArrayItems.AllOf, sub)
			}

			inline := NewSchema()
			{
				tmp := NewSchema()
				tmp.setType("string")
				tmp.Enum = names
				tmp.Description = fmt.Sprintf("%s name\n%s", f.LoaderKey, f.description("string"))

				inline.Properties[f.LoaderKey] = tmp
				s.ArrayItems.AllOf = append(s.ArrayItems.AllOf, inline)
			}

			s.ArrayItems.Required = []string{f.LoaderKey}
		} else {
			// matchers e.t.c.
			for _, l := range f.Loader {
				split := strings.Split(l, ".")
				name := split[len(split)-1]

				ref := NewSchema()
				ref.setRef(l)

				s.ArrayItems.Properties[name] = ref
			}
		}
	}

	for _, field := range f.Fields {
		s.Properties[field.Name] = field.toSchema()
	}

	// get arrays and maps
	for cs, outer, nest := s, &f, f.Nest; nest != nil; outer, nest = nest, nest.Nest {
		props := map[string]*Schema{}
		for _, field := range nest.Fields {
			props[field.Name] = field.toSchema()
		}
		if outer.Array {
			cs.setType("array")
			cs.ArrayItems = NewSchema()
			cs.ArrayItems.setType(nest.Type)
			cs.ArrayItems.Properties = props

			// nest schema
			cs = cs.ArrayItems
		}

		if outer.Map {
			cs.setType("object")
			cs.AdditionalProperties = NewSchema()
			cs.AdditionalProperties.Properties = props

			// nest schema
			cs = cs.AdditionalProperties
		}
	}

	// now we're certain of the type
	s.Description = f.description(s.Type)
	return s
}

func (f *Field) populate(s interface{}) {
	v := reflect.ValueOf(s)

	elemVal := func() interface{} { return reflect.Zero(v.Type().Elem()).Interface() }

	switch v.Kind() {
	case reflect.Struct:
		f.populateStruct(v.Type())

	case reflect.Ptr:
		// discard the pointer, use the underlying type
		f.populate(elemVal())

	case reflect.Slice:
		f.Array = true
		f.Nest = &Field{
			Module: f.Module,
			Name:   f.Name + ".nest",
		}
		f.Nest.populate(elemVal())

	case reflect.Map:
		f.Map = true
		f.Nest = &Field{
			Module: f.Module,
			Name:   f.Name + ".nest",
		}
		f.Nest.populate(elemVal())

	default:
		f.populateStruct(v.Type())
	}

}

func (f *Field) populateStruct(t reflect.Type) {
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	if t.Kind() != reflect.Struct {
		f.Type = t.Kind().String()
		return
	}

	for _, ff := range allFields(t) {
		jsonTag, ok := ff.Tag.Lookup("json")
		if !ok || jsonTag == "-" {
			continue
		}

		field := Field{
			Module: f.Module,
			Name:   strings.TrimSuffix(jsonTag, ",omitempty"),
		}

		caddyTag, ok := ff.Tag.Lookup("caddy")
		if ok {
			split := strings.Fields(caddyTag)
			namespace := split[0] // 1 is inline_key
			namespace = strings.TrimPrefix(namespace, "namespace=")
			// use namespace as module
			field.Module = namespace

			if len(split) > 1 {
				field.LoaderKey = strings.TrimPrefix(split[1], "inline_key=")
			}

			for key := range moduleMap[namespace] {
				field.Loader = append(field.Loader, namespace+"."+key)
			}
		} else {
			vf := reflect.Zero(ff.Type)
			field.populate(vf.Interface())
		}

		f.Fields = append(f.Fields, field)
	}

}

func allFields(t reflect.Type) []reflect.StructField {
	// dereference pointer
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	// reject non-structs
	if t.Kind() != reflect.Struct {
		return nil
	}

	var fields []reflect.StructField

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)

		if f.Anonymous {
			fields = append(fields, allFields(f.Type)...)
		} else {
			fields = append(fields, f)
		}

	}
	return fields
}
