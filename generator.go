package jsonschema

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"reflect"
	"strings"
	"unicode"

	"github.com/caddyserver/caddy/v2"
	caddycmd "github.com/caddyserver/caddy/v2/cmd"
)

func init() {
	caddycmd.RegisterCommand(caddycmd.Command{
		Name:  "json-schema",
		Func:  cmdSchema,
		Usage: "[--output <file>]",
		Short: "Generate JSON schema for Caddy JSON api",
		Long: `
JSON schema generator for caddy JSON configuration. More at https://json-schema.org

If --output is set, the schema is generated to the specified file. By default it is
generated to caddy_json_schema.json in the current directory.
`,
		Flags: func() *flag.FlagSet {
			fs := flag.NewFlagSet("json-schema", flag.ExitOnError)
			fs.String("output", "./caddy_json_schema.json", "The file to write the generated schema")
			return fs
		}(),
	})
}

func cmdSchema(fs caddycmd.Flags) (int, error) {
	if err := loadJSONDoc(); err != nil {
		return caddy.ExitCodeFailedQuit, err
	}

	if err := generateSchema(); err != nil {
		return caddy.ExitCodeFailedQuit, err
	}

	if err := writeSchema(); err != nil {
		return caddy.ExitCodeFailedQuit, err
	}

	return 0, nil
}

func generateSchema() error {
	// fetch all caddy modules available in current build
	for _, mod := range caddy.Modules() {
		split := strings.Split(mod, ".")

		parent := "" // top level modules
		name := split[len(split)-1]
		if len(split) >= 2 {
			// submodules
			parent = strings.Join(split[:len(split)-1], ".")
		}

		info, err := caddy.GetModule(mod)
		if err != nil {
			return err
		}

		if moduleMap[parent] == nil {
			moduleMap[parent] = Modules{}
		}

		newInfo := info.New()
		module := Module{
			Name: name,
			Type: newInfo,
			Field: Field{
				Name:   name,
				Module: mod,
			},
		}

		moduleMap[parent][name] = module
		flatModuleMap[mod] = module
	}

	// schema generation
	// use separate loop to ensure module list has populated.
	{
		// all module definitions
		definitions := map[string]*Schema{}

		for modName, module := range flatModuleMap {
			module.Field.populate(module.Type)
			schema := module.Field.toSchema()
			if doc, ok := flatCaddyDocMap[modName]; ok {
				addDocToSchema(schema, doc.Structure)
			}
			definitions[modName] = schema
		}

		// full config
		configField := Field{}
		configField.populate(caddy.Config{})
		globalSchema = configField.toSchema()
		globalSchema.Definitions = definitions

		// in case this schema is incomplete, support additional custom items.
		globalSchema.AdditionalItems = true

		// docs
		globalSchema.Title = "Caddy v2 autogenerated JSON schema  \nhttps://github.com/abiosoft/caddy-json-schema"
		globalSchema.Type = "object"
		if caddyDoc.Structure != nil {
			addDocToSchema(globalSchema, caddyDoc.Structure)
		}

	}

	return nil
}

func addDocToSchema(s *Schema, doc *DocStruct) {
	if s == nil || doc == nil {
		return
	}

	desc := func(description, pkg, doc string) string {
		pkg = godocLink(pkg)
		desc := ""
		for _, d := range []string{description, pkg, doc} {
			if d != "" {
				desc += d + "\n"
			}
		}
		return desc
	}
	mdDesc := func(description, pkg, doc string) string {
		pkg = markdownLink("godoc", godocLink(pkg))
		desc := ""
		for _, d := range []string{description, pkg, doc} {
			if strings.TrimSpace(d) != "" {
				desc += d + "  \n"
			}
		}
		return desc
	}
	setDesc := func(s *Schema, d *DocStruct) {
		s.Description = desc(s.description, d.Package, d.Doc)
		s.MarkdownDescription = mdDesc(s.markdownDescription, d.Package, d.Doc)
	}

	// set only if non-empty, parent may have set the doc if empty
	if doc.Doc != "" {
		setDesc(s, doc)
	}

	switch doc.Type {
	case "struct":
		for i, field := range doc.StructFields {
			if _, ok := s.Properties[field.Key]; ok {
				// if field has no doc, use parent doc.
				if field.Value.Doc == "" {
					setDesc(s.Properties[field.Key], field)
				}
				addDocToSchema(s.Properties[field.Key], doc.StructFields[i].Value)
			}
		}
	case "array":
		if s.ArrayItems != nil && doc.Elems != nil {
			if doc.Elems.Doc != "" {
				setDesc(s, doc.Elems) // use items doc for parent
			}
			addDocToSchema(s.ArrayItems, doc.Elems)
		}
	case "map":
		if s.AdditionalProperties != nil && doc.Elems != nil {
			if doc.Elems.Doc != "" {
				setDesc(s, doc.Elems) // use items doc for parent
			}
			addDocToSchema(s.AdditionalProperties, doc.Elems)
		}
	default:
		// everything else has no nesting
		// do nothing/terminate
	}

}

func writeSchema() error {
	f, err := os.OpenFile("schema.json", os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer f.Close()

	encoder := json.NewEncoder(f)
	encoder.SetIndent("", "  ")

	// var err error
	err = encoder.Encode(globalSchema)
	return err

}

// Field ...
type Field struct {
	// keep track of the current module
	Module string

	// field properties
	Name   string
	Fields []Field
	Type   string

	// array/map type
	Array bool
	Map   bool // map key is always string
	Nest  *Field

	// Module loaders
	Loader     []string // list of modules
	LoaderKey  string   // inline_key
	LoaderType reflect.Type
}

func (f Field) goPkg() string {
	typ := reflect.TypeOf(flatModuleMap[f.Module].Type)
	if typ == nil {
		return ""
	}

	if typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}

	// only return godoc for public fields
	if typ.Name() != "" {
		c := rune(typ.Name()[0])
		if unicode.IsUpper(c) && unicode.IsLetter(c) {
			return typ.PkgPath() + "." + typ.Name()
		}
	}

	return ""
}

func (f Field) toSchema() *Schema {
	var s = NewSchema()
	s.setType(f.Type)

	if len(f.Loader) > 0 {
		sl := NewSchema()

		if f.LoaderKey != "" {
			// when loader key is set, we expect a []module.
			// combine {if, then} to improve suggestions.
			names := []string{}
			for _, l := range f.Loader {
				sub := NewSchema()

				sif := NewSchema()
				{
					split := strings.Split(l, ".")
					name := split[len(split)-1]

					tmp := NewSchema()
					tmp.Const = name
					names = append(names, name)

					sif.Properties[f.LoaderKey] = tmp
					sub.If = sif
				}

				sthen := NewSchema()
				{
					sthen.setRef(l)
					sub.Then = sthen
				}

				sl.AllOf = append(sl.AllOf, sub)
			}

			// make loaderKey a required field
			inline := NewSchema()
			{
				tmp := NewSchema()
				tmp.setType("string")
				tmp.Enum = names

				// No way to generate docs for this yet.
				// TODO: make it reflect the current handler.
				desc := "key to identify %s module.\n%s: string\nModule: %s"
				mdDesc := "key to identify `%s` module.  \n%s: `string`  \nModule: `%s`"
				tmp.Description = fmt.Sprintf(desc, f.Name, f.LoaderKey, f.Module)
				tmp.MarkdownDescription = fmt.Sprintf(mdDesc, f.Name, f.LoaderKey, f.Module)

				inline.Properties[f.LoaderKey] = tmp
				sl.AllOf = append(sl.AllOf, inline)
			}

			sl.Required = []string{f.LoaderKey}
		} else {
			// when loader key is absent, we expect a map[string]module
			for _, l := range f.Loader {
				split := strings.Split(l, ".")
				name := split[len(split)-1]

				ref := NewSchema()
				ref.setRef(l)

				sl.Properties[name] = ref
			}
		}

		// hack to determine the module loader type
		{
			// generate schema
			var tField Field
			tField.populate(reflect.Zero(f.LoaderType).Interface())
			loaderSchema := tField.toSchema()

			// determine how nested the module loader is
			var nest int
			for cs := loaderSchema; cs.ArrayItems != nil || cs.AdditionalProperties != nil; nest++ {
				if cs.ArrayItems != nil {
					cs = cs.ArrayItems
				} else if cs.AdditionalProperties != nil {
					cs = cs.AdditionalProperties
				}
			}

			// derive from the nesting the structure of the module loader
			// TODO: use a different approach to improve readability
			switch nest {
			case 1:
				// module
				s.setType("object")
				s = sl
			case 2:
				if f.LoaderKey == "" {
					// map[string]module
					s.setType("object")
					s = sl
				} else {
					// []module
					s.setType("array")
					s.ArrayItems = sl
				}
			case 3:
				// []map[string]module
				s.setType("array")
				s.ArrayItems = sl
			}
		}
	}

	// struct fields
	for _, field := range f.Fields {
		s.Properties[field.Name] = field.toSchema()
	}

	// get arrays and maps
	for cs, outer, nest := s, &f, f.Nest; nest != nil; outer, nest = nest, nest.Nest {
		props := map[string]*Schema{}
		for _, field := range nest.Fields {
			props[field.Name] = field.toSchema()
		}
		if outer.Array {
			cs.setType("array")
			cs.ArrayItems = NewSchema()
			cs.ArrayItems.setType(nest.Type)
			cs.ArrayItems.Properties = props

			// nest schema
			cs = cs.ArrayItems
		}

		if outer.Map {
			cs.setType("object")
			cs.AdditionalProperties = NewSchema()
			cs.AdditionalProperties.Properties = props

			// nest schema
			cs = cs.AdditionalProperties
		}
	}

	// now we're certain of the type
	s.description = description(f.Name, s.Type, f.Module)
	s.markdownDescription = markdownDescription(f.Name, s.Type, f.Module)
	s.goPkg = f.goPkg()

	// set the description in case JSON api docs not available
	// e.g. third party modules
	s.Description = s.description + "\n" + godocLink(s.goPkg)
	s.MarkdownDescription = s.markdownDescription + "  \n" + markdownLink("godoc", godocLink(s.goPkg))
	if s.goPkg == "" {
		s.Description = s.description
		s.MarkdownDescription = s.markdownDescription
	}
	return s
}

func (f *Field) populate(s interface{}) {
	v := reflect.ValueOf(s)

	elemVal := func() interface{} { return reflect.Zero(v.Type().Elem()).Interface() }

	switch v.Kind() {
	case reflect.Struct:
		f.populateStruct(v.Type())

	case reflect.Ptr:
		// discard the pointer, use the underlying type
		f.populate(elemVal())

	case reflect.Slice:
		f.Array = true
		f.Nest = &Field{
			Module: f.Module,
			Name:   f.Name + ".nest",
		}
		f.Nest.populate(elemVal())

	case reflect.Map:
		f.Map = true
		f.Nest = &Field{
			Module: f.Module,
			Name:   f.Name + ".nest",
		}
		f.Nest.populate(elemVal())

	default:
		f.populateStruct(v.Type())
	}

}

func (f *Field) populateStruct(t reflect.Type) {
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	if t.Kind() != reflect.Struct {
		f.Type = t.Kind().String()
		return
	}

	for _, ff := range allFields(t) {
		jsonTag, ok := ff.Tag.Lookup("json")
		if !ok || jsonTag == "-" {
			continue
		}

		field := Field{
			Module: f.Module,
			Name:   strings.TrimSuffix(jsonTag, ",omitempty"),
		}

		caddyTag, ok := ff.Tag.Lookup("caddy")
		if ok {
			split := strings.Fields(caddyTag)
			namespace := split[0] // 1 is inline_key
			namespace = strings.TrimPrefix(namespace, "namespace=")
			// use namespace as module
			field.Module = namespace
			field.LoaderType = ff.Type

			if len(split) > 1 {
				field.LoaderKey = strings.TrimPrefix(split[1], "inline_key=")
			}

			for key := range moduleMap[namespace] {
				modulePath := key
				if namespace != "" {
					modulePath = namespace + "." + key
				}
				field.Loader = append(field.Loader, modulePath)
			}
		} else {
			vf := reflect.Zero(ff.Type)
			field.populate(vf.Interface())
		}

		f.Fields = append(f.Fields, field)
	}

}

func allFields(t reflect.Type) []reflect.StructField {
	// dereference pointer
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	// reject non-structs
	if t.Kind() != reflect.Struct {
		return nil
	}

	var fields []reflect.StructField

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)

		if f.Anonymous {
			fields = append(fields, allFields(f.Type)...)
		} else {
			fields = append(fields, f)
		}

	}
	return fields
}
